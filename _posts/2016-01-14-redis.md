---
layout: post
title:  "redis笔记"
date:   2016-01-14 09:05:31
categories: memcached
tags: memcached
---

* content
{:toc}



# 一、简介与安装

## 简介

redis 是开源的BSD许可的，在内存存储结构化数据，可以被用来作为数据库，缓存，消息中介。

redis 与 memcached 对比：

* redis 可以用作存储，memcached 只能用作缓存
* redis 存储的数据可以是结构化的，memcached只有string
* redis 可以做任务队列，订阅等
* redis 可以做主从复制

## 安装

下载最新的[stable源码](http://download.redis.io/redis-stable.tar.gz)


{% highlight python %}
yum install tcl # 依赖tcl
make  # 不用configure
make test  # 可选
make install  # 可以增加 PREFIX=/usr/local/redis  指定安装目录
{% endhighlight %}

安装后得到如下文件：

* redis-benchmark  性能测试工具
* redis-check-aof  日志文件检测工具
* redis-check-dump 快照文件检测工具
* redis-cli 客户端
* redis-server 服务端

## 启动

`redis-server`  直接启动 默认端口6379

`redis-server --port 6380`  指定端口启动

`redis-server redis.conf`  使用配置文件启动

修改配置文件 `daemonize yes` 以后台进程形式启动

redis 源码目录有 utils 文件夹，有`redis-init-script`脚本

可以拷贝到`/etc/init.d/`目录，并修改相关配置，方便管理redis

然后增加服务并开机自启动：
{% highlight python %}
# chmod 755 /etc/init.d/redis
# chkconfig --add redis
# chkconfig --level 345 redis on
# chkconfig --list redis
{% endhighlight %}

## 连接

redis-cli 是 Redis Command Line Interface 的缩写

两种方式发送命令

* 连接redis 通过-h 和 -p 参数
{% highlight python %}
$ redis-cli -h 127.0.0.1 -p 6379
$ redis-cli PING
PONG
{% endhighlight %}

* 通过交互方式
{% highlight python %}
$ redis-cli
redis 127.0.0.1:6379> PING
PONG
redis 127.0.0.1:6379> ECHO hi
"hi"
{% endhighlight %}

命令返回值：
{% highlight python %}
1，状态回复
显示状态信息
redis 127.0.0.1:6379> PING
PONG
2，错误回复
错误回复以(error)开头
redis 127.0.0.1:6379> SOMETHING
(error) ERR unknown command 'SOMETHING'
3，整数回复
以(integer)开头
redis 127.0.0.1:6379> INCR foo
(integer) 1
4，字符串回复
双引号包裹
redis 127.0.0.1:6379> GET foo
"1"
特殊
redis 127.0.0.1:6379> GET noexists
(nil)
5，多行字符串回复
redis 127.0.0.1:6379> KEYS *
1) "foo"
2) "bar"
{% endhighlight %}

## 关闭

`redis-cli SHUTDOWN`  使用客户端命令关闭更安全

结束进程
{% highlight python %}
ps -ef|grep redis
kill -9 pid
或者
pkill -9 redis
{% endhighlight %}


# 二、redis基础命令和数据结构

## 对key的操作命令

### 获得符合规则的键名列表

KYES pattern

pattern 支持glob风格通配符格式:

* `?` 匹配一个字符
* `*` 匹配任意个，包含0个 字符
* `[]` 匹配括号间的任一字符
* `\x`  匹配字符x，x为特殊字符，比如\? 匹配?

{% highlight python %}
redis 127.0.0.1:6379> set x 1
OK
redis 127.0.0.1:6379> keys *
1) "x"
redis 127.0.0.1:6379> keys x
1) "x"
{% endhighlight %}

### 判断一个键是否存在

EXISTS key
{% highlight python %}
redis 127.0.0.1:6379> exists x
(integer) 1
redis 127.0.0.1:6379> exists y
(integer) 0
{% endhighlight %}

### 删除键

DEL key [key ...]

删除一个或者多个键，返回值为删除键的个数

{% highlight python %}
redis 127.0.0.1:6379> del x
(integer) 1
redis 127.0.0.1:6379> del x
(integer) 0
{% endhighlight %}

DEL 命令的参数不支持通配符，可以使用linux通配符来操作
{% highlight python %}
redis-cli KEYS "x*" | xargs redis-cli  DEL
或者
redis-cli  DEL  `redis-cli KEYS "x*"`
{% endhighlight %}

### 获得键值的数据类型

TYPE key

TYPE命令用来获得键值的数据类型，返回值可能是string （字符串类型）、hash （散列类
型）、list （列表类型）、set （集合类型）、zset （有序集合类型）

{% highlight python %}
redis 127.0.0.1:6379> set a 1
OK
redis 127.0.0.1:6379> type a
string
# LPUSH 命令的作用是向指定列表类型键中增加一个元素，如果键不存在则创建
redis 127.0.0.1:6379> lpush aa 1
(integer) 1
redis 127.0.0.1:6379> type aa
list
{% endhighlight %}

### 重命名

RENAME key newkey

注:如果newkey已存在,则newkey的原值被覆盖

RENAMENX key newkey

注: nx--> not exists, 即, newkey不存在时,作改名动作

### 转移DB

MOVE key db

默认打开16个数据库,从0到15编号,可以从配置文件修改

{% highlight python %}
127.0.0.1:6379[15]> keys *
(empty list or set)
127.0.0.1:6379[15]> set name hehe
OK
127.0.0.1:6379[15]> set age 23
OK
127.0.0.1:6379[15]> keys *
1) "age"
2) "name"
127.0.0.1:6379[15]> move name 14
(integer) 1
127.0.0.1:6379[15]> keys *
1) "age"
127.0.0.1:6379[15]> select 14
OK
127.0.0.1:6379[14]> get name
"hehe"
{% endhighlight %}

### 随机返回key

RANDOMKEY

{% highlight python %}
127.0.0.1:6379[14]> randomkey
"name"
{% endhighlight %}

### 判断key是否存在

EXISTS key

{% highlight python %}
127.0.0.1:6379[14]> exists name
(integer) 1
127.0.0.1:6379[14]> exists noname
(integer) 0
{% endhighlight %}

### 设置key的生命周期

TTL key  查看ttl

EXPIRE key num  设置生命周期（秒）

PERSIST key  设置永久

{% highlight python %}

127.0.0.1:6379[14]> ttl name
(integer) -1
127.0.0.1:6379[14]> expire name 600
(integer) 1
127.0.0.1:6379[14]> ttl name
(integer) 597
127.0.0.1:6379[14]> persist name
(integer) 1
127.0.0.1:6379[14]> ttl name
(integer) -1
{% endhighlight %}


## 字符串

### 赋值

SET key value [ex 秒数]/[px 毫秒数] [nx]/[xx]

nx 表示key不存在时，执行操作
xx 表示key 存在时，执行操作

如果 ex 和 px 同时写，以后面的有效期为准

例如： `set a 1 ex px 9000` 实际有效期是9000毫秒

MSET key1 value1 key2 value2 一次性设置多个键值

例如： `mset key1 v1 key2 v2`


### 取值

GET key 获取key的值

MGET key1 key1 获取多个key

{% highlight python %}
127.0.0.1:6379[14]> mget key1 key2
1) "v1"
2) "v2"
{% endhighlight %}


### 其他的值操作

SETRANGE key offset value

把字符串的offset偏移字节改为value

如果偏移字节大于字符串长度，空缺部分，自动补`\x00`

{% highlight python %}
127.0.0.1:6379[14]> set name mouren
OK
127.0.0.1:6379[14]> get name
"mouren"
127.0.0.1:6379[14]> setrange name 0 x
(integer) 6
127.0.0.1:6379[14]> get name
"xouren"
127.0.0.1:6379[14]> setrange name 10 x
(integer) 11
127.0.0.1:6379[14]> get name
"xouren\x00\x00\x00\x00x"
{% endhighlight %}

APPEND key value

将value追加到key的原值后面

如果没有key，则设置key为value

{% highlight python %}
127.0.0.1:6379[14]> set name hello
OK
127.0.0.1:6379[14]> append name world
(integer) 10
127.0.0.1:6379[14]> get name
"helloworld"
127.0.0.1:6379[14]> get none
(nil)
127.0.0.1:6379[14]> append none nothing
(integer) 7
127.0.0.1:6379[14]> get none
"nothing"
{% endhighlight %}


GETRANGE key start stop

获取字符串中 start 到stop 范围的值
{% highlight python %}
127.0.0.1:6379[14]> getrange name 0 2
"hel"
127.0.0.1:6379[14]> getrange name  2 -1
"lloworld"
{% endhighlight %}


GETSET key value

返回旧值，并设置新值

{% highlight python %}
127.0.0.1:6379[14]> set name hello
OK
127.0.0.1:6379[14]> getset name world
"hello"
127.0.0.1:6379[14]> get name
"world"
{% endhighlight %}

STRLEN key

获得字符串长度

{% highlight python %}
127.0.0.1:6379[14]> get none
"nothing"
127.0.0.1:6379[14]> strlen none
(integer) 7
{% endhighlight %}


### 递增数字

INCR key

指定key的值加1，并返回加1后的值

{% highlight python %}
redis 127.0.0.1:6379> incr num
(integer) 1
redis 127.0.0.1:6379> get num
"1"
redis 127.0.0.1:6379> type num
string
redis 127.0.0.1:6379> incr num
(integer) 2
{% endhighlight %}

当操作的键不存在默认键值为0，所以第一次递增后结果为1.

当键值不是整数redis会提示错误

{% highlight python %}
redis 127.0.0.1:6379> set foo xx
OK
redis 127.0.0.1:6379> incr foo
(error) ERR value is not an integer or out of range
{% endhighlight %}

自己通过GET 和 SET 实现 incr 函数，会有问题

{% highlight python %}
def incr(key):
     value = GET key
     if not value:
          value = 0
     value += 1
     SET key, value
{% endhighlight %}

当多个客户端连接的时候，可能出现竞态条件。

比如A,客户端都操作同一个键，恰好均取到键值一样，比如“5”，各自将键值增加到“6”，最后得到的是“6”，而不是想要的“7”。

所有的redis命令均为原子操作，无论多少客户端同时连接，均不会出现上述情况。


INCRBY key num

指定key的值，加num

{% highlight python %}
127.0.0.1:6379[14]> set n 1
OK
127.0.0.1:6379[14]> incrby n 10
(integer) 11
127.0.0.1:6379[14]> get n
"11"
{% endhighlight %}

INCRBYFLOAT key floatnum

指定key值，增加float的数值

{% highlight python %}
127.0.0.1:6379[14]> set f 1.9
OK
127.0.0.1:6379[14]> incrbyfloat f 2.3
"4.2"
127.0.0.1:6379[14]> get f
"4.2"
{% endhighlight %}


DECR key

指定key的值，减少1

DECRBY key num

指定key的值，减少num

{% highlight python %}
127.0.0.1:6379[14]> get n
"11"
127.0.0.1:6379[14]> decr n
(integer) 10
127.0.0.1:6379[14]> decrby n 5
(integer) 5
127.0.0.1:6379[14]> get n
"5"
{% endhighlight %}


### 位操作

GETBIT key offset

SETBIT key offset value

BITCOUNT key [start] [end]

BITOP operation destkey key [key ...]


一个字节由8个二进制位组成

举例：
{% highlight python %}
127.0.0.1:6379> SET foo bar
OK
{% endhighlight %}

bar 的3个字母对应的ASCII码分别为98、97和114，转换为二进制分别为1100010、1100001、1110010

所以foo键的二进制位结构如下

![redis_bit.png](/files/redis_bit.png)

GETBIT命令可以获得一个字符串类型键指定二进制位的值（0或者1），索引从0开始。超出长度的默认位值为0



{% highlight python %}
127.0.0.1:6379> getbit foo 18
(integer) 1
127.0.0.1:6379> getbit foo 20
(integer) 0
127.0.0.1:6379> getbit foo 200
(integer) 0
{% endhighlight %}


SETBIT可以设置字符串类型键指定位置的二进制位的值，返回值是该位置旧的值

offset最大2^32-1,可推出最大的的字符串为512M

{% highlight python %}
127.0.0.1:6379> setbit foo 6 0
(integer) 1
127.0.0.1:6379> setbit foo 7 1
(integer) 0
127.0.0.1:6379> get foo
"aar"
{% endhighlight %}

如果设置位置超过键值的二进制长度，自动将中间位置设置为0

{% highlight python %}
127.0.0.1:6379> setbit nofoo 10 1
(integer) 0
127.0.0.1:6379> getbit nofoo 5
(integer) 0
127.0.0.1:6379> get nofoo
"\x00 "
{% endhighlight %}

BITCOUNT 命令可以获得字符串类型中值为1的二进制位个数
{% highlight python %}
127.0.0.1:6379> bitcount foo
(integer) 10
{% endhighlight %}

可以指定开始和结束的字节数 比如只统计'a' 或者'aa'
{% highlight python %}
127.0.0.1:6379> bitcount foo 0 0
(integer) 3
127.0.0.1:6379> bitcount foo 0 1
(integer) 6
{% endhighlight %}

BITOP可以对多个字符串类型键进行位运算，并将结果存储在destkey中。支持的运算操作包括AND,OR,XOR,NOT

注意: 对于NOT操作, key不能多个

{% highlight python %}
127.0.0.1:6379> set foo1 bar
OK
127.0.0.1:6379> set foo2 aar
OK
127.0.0.1:6379> bitop or res foo1 foo2
(integer) 3
127.0.0.1:6379> get res
"car"
{% endhighlight %}


## 列表类型

列表类型内部是使用双链表实现的。

LPUSH key value [value ...]

RPUSH key value [value ...]

向列表左、右插入元素

{% highlight python %}
127.0.0.1:6379[14]> lpush list a
(integer) 1
127.0.0.1:6379[14]> lpush list b c
(integer) 3
127.0.0.1:6379[14]> rpush list d
(integer) 4
127.0.0.1:6379[14]> lrange list 0 -1
1) "c"
2) "b"
3) "a"
4) "d"
{% endhighlight %}


LPOP key

RPOP key

从列表的左、右弹出元素

{% highlight python %}
127.0.0.1:6379[14]> rpop list
"d"
127.0.0.1:6379[14]> lpop list
"c"
{% endhighlight %}


LRANGE key start stop

获取列表的片段

LLEN key

获取元素的个数


{% highlight python %}
127.0.0.1:6379[14]> lrange list 0 -1
1) "b"
2) "a"
127.0.0.1:6379[14]> llen list
(integer) 2
{% endhighlight %}

LREM key count value

删除列表中指定的值

* 当 count＞0时LREM命令会从列表左边开始删除前count个值为value的元素；
* 当 count＜ 0时LREM 命令会从列表右边开始删除前count个值为value的元素；
* 当 count=0是LREM命令会删除所有值为value的元素

{% highlight python %}
127.0.0.1:6379[14]> rpush numbers 2 1 0 2 3 1 3 2
(integer) 8
127.0.0.1:6379[14]> lrange numbers 0 -1
1) "2"
2) "1"
3) "0"
4) "2"
5) "3"
6) "1"
7) "3"
8) "2"
# 右侧删除
127.0.0.1:6379[14]> lrem numbers -1 3
(integer) 1
127.0.0.1:6379[14]> lrange numbers 0 -1
1) "2"
2) "1"
3) "0"
4) "2"
5) "3"
6) "1"
7) "2"
# 全部删除
127.0.0.1:6379[14]> lrem numbers 0 1
(integer) 2
127.0.0.1:6379[14]> lrange numbers 0 -1
1) "2"
2) "0"
3) "2"
4) "3"
5) "2"
# 左侧删除
127.0.0.1:6379[14]> lrem numbers 2 2
(integer) 2
127.0.0.1:6379[14]> lrange numbers 0 -1
1) "0"
2) "3"
3) "2"
{% endhighlight %}


LINDEX key index

LSET key index value

获得和设置指定索引元素

{% highlight python %}
127.0.0.1:6379[14]> lrange numbers 0 -1
1) "0"
2) "3"
3) "2"
127.0.0.1:6379[14]> lindex numbers 1
"3"
127.0.0.1:6379[14]> lset numbers 1 8
OK
127.0.0.1:6379[14]> lindex numbers 1
"8"
{% endhighlight %}


LSTRIM key start end

只保留列表指定片段

{% highlight python %}
127.0.0.1:6379[14]> lrange numbers 0 -1
1) "0"
2) "8"
3) "2"
127.0.0.1:6379[14]> ltrim numbers 0 1
OK
127.0.0.1:6379[14]> lrange numbers 0 -1
1) "0"
2) "8"
{% endhighlight %}


LINSERT  key AFTER/BEFORE search value

从左到右查找search，找到的话插入value

一旦找到一个search后,命令就结束了,因此不会插入多个value

{% highlight python %}
127.0.0.1:6379[14]> lrange numbers 0 -1
1) "0"
2) "8"
127.0.0.1:6379[14]> linsert numbers after 3 9
(integer) -1
127.0.0.1:6379[14]> lrange numbers 0 -1
1) "0"
2) "8"
127.0.0.1:6379[14]> linsert numbers after 8 9
(integer) 3
127.0.0.1:6379[14]> lrange numbers 0 -1
1) "0"
2) "8"
3) "9"
{% endhighlight %}

RPOPLPUSH source destination

从source右边弹出元素，放入destination左侧

{% highlight python %}
127.0.0.1:6379[14]> lpush source 1 2 3 4 5 6 7
(integer) 7
127.0.0.1:6379[14]> rpoplpush source destination
"1"
127.0.0.1:6379[14]> rpoplpush source destination
"2"
127.0.0.1:6379[14]> lrange destination 0 -1
1) "2"
2) "1"
127.0.0.1:6379[14]> lrange source 0 -1
1) "7"
2) "6"
3) "5"
4) "4"
5) "3"
{% endhighlight %}

BRPOP key timeout

BLPOP key timeout

等待弹出key元素，timeout为超时时间，0 则一直等待

可应用到 长轮询ajax，在线聊天，缓存队列等

## HASH 类型

### 赋值和取值

HSET key field value

HGET key field

HMSET key field value [field value ...]

HMGET key field [field ...]

HGETALL key

{% highlight python %}
127.0.0.1:6379[14]> hset car price 50w
(integer) 1
127.0.0.1:6379[14]> hset car name bmw
(integer) 1
127.0.0.1:6379[14]> hget car name
"bmw"
127.0.0.1:6379[14]> hmget car name price
1) "bmw"
2) "50w"
127.0.0.1:6379[14]> hgetall
(error) ERR wrong number of arguments for 'hgetall' command
127.0.0.1:6379[14]> hgetall car
1) "price"
2) "50w"
3) "name"
4) "bmw"

{% endhighlight %}

### 字段操作

HEXISTS key field

判断字段是否存在

{% highlight python %}

127.0.0.1:6379[14]> hgetall car
1) "price"
2) "50w"
3) "name"
4) "bmw"
127.0.0.1:6379[14]> hexists car model
(integer) 0
127.0.0.1:6379[14]> hexists car name
(integer) 1
{% endhighlight %}

HSETNX key field value

当字段不存在时，赋值

{% highlight python %}

127.0.0.1:6379[14]> hgetall car
1) "price"
2) "50w"
3) "name"
4) "bmw"
127.0.0.1:6379[14]> hsetnx car name auto
(integer) 0
127.0.0.1:6379[14]> hsetnx car age 5
(integer) 1
{% endhighlight %}

HDEL key field [field ..]

删除字段

{% highlight python %}
127.0.0.1:6379[14]> hdel car name
(integer) 1
127.0.0.1:6379[14]> hgetall car
1) "price"
2) "50w"
3) "age"
4) "5"
{% endhighlight %}

HINCRBY key field num

增加字段值，若字段不存在则默认为0
{% highlight python %}
127.0.0.1:6379[14]> hincrby car length 30
(integer) 30
127.0.0.1:6379[14]> hincrby car length 3
(integer) 33
{% endhighlight %}

HINCRBYFLOAT key field floatnum

增加浮点值

{% highlight python %}
127.0.0.1:6379[14]> hincrbyfloat car age 1.2
"6.2"
{% endhighlight %}

HKEYS key

HVALS key

值获取 字段名 或者 值

{% highlight python %}
127.0.0.1:6379[14]> hkeys car
1) "price"
2) "age"
3) "length"

127.0.0.1:6379[14]> hvals car
1) "50w"
2) "5"
3) "33"
{% endhighlight %}


HLEN key

获取字段数量

{% highlight python %}
127.0.0.1:6379[14]> hlen car
(integer) 3
{% endhighlight %}

## 集合类型

集合是无序的、唯一的。最多存储2^32 - 1 个元素

内部使用值为空的hash实现，所以插入、删除、判断元素的时间复杂度为O(1)

SADD key number [number ...]

SREM key number [number ...]

增加或者删除元素

{% highlight python %}

127.0.0.1:6379[14]> sadd letters a
(integer) 1
127.0.0.1:6379[14]> sadd letters a b c
(integer) 2
127.0.0.1:6379[14]> smembers letters
1) "b"
2) "a"
3) "c"
127.0.0.1:6379[14]> srem letters c
(integer) 1
127.0.0.1:6379[14]> smembers letters
1) "b"
2) "a"
{% endhighlight %}

SMEMBERS key

返回集合中的元素

{% highlight python %}

127.0.0.1:6379[14]> smembers letters
1) "b"
2) "a"
{% endhighlight %}

SISMEMBER key number

判断是否存在某个元素

{% highlight python %}

127.0.0.1:6379[14]> sismember letters a
(integer) 1
127.0.0.1:6379[14]> sismember letters c
(integer) 0
{% endhighlight %}


SPOP key

随机删除一个元素

{% highlight python %}

127.0.0.1:6379[14]> smembers letters
1) "a"
2) "c"
3) "d"
4) "f"
5) "b"
6) "e"
127.0.0.1:6379[14]> spop letters
"f"
127.0.0.1:6379[14]> spop letters
"a"
{% endhighlight %}

SRANDMEMBER key

随机返回一个值

{% highlight python %}

127.0.0.1:6379[14]> smembers letters
127.0.0.1:6379[14]> srandmember letters
"c"
127.0.0.1:6379[14]> srandmember letters
"e"
{% endhighlight %}

SCARD key

集合含有元素个数

{% highlight python %}

127.0.0.1:6379[14]> smembers letters
1) "d"
2) "b"
3) "e"
4) "c"
127.0.0.1:6379[14]> scard letters
(integer) 4
{% endhighlight %}

SMOVE source destination value

将一个集合的值，移动到另外一个集合

{% highlight python %}
127.0.0.1:6379[14]> smembers letters
1) "d"
2) "b"
3) "e"
4) "c"
127.0.0.1:6379[14]> smove letters newletters d
(integer) 1
127.0.0.1:6379[14]> smembers newletters
1) "d"
127.0.0.1:6379[14]> smembers letters
1) "b"
2) "e"
3) "c"
{% endhighlight %}

### 集合操作

SDIFF key [key ...] 差集

SINTER key [key ...] 并集

SUNION key [key ...] 交集

SINTERSTORE dest key [key ...] 差集并存储到dest

SINTERSTORE key [key ...] 并集并存储到dest

SUNIONSTORE key [key ...] 交集并存储到dest

{% highlight python %}

127.0.0.1:6379[14]> sadd s1 1 2 3 4 5 6
(integer) 6
127.0.0.1:6379[14]> sadd s2 3 4 5 6 7
(integer) 5
127.0.0.1:6379[14]> sadd s3 5 6 7 8 9
(integer) 5
127.0.0.1:6379[14]> sdiff s1 s2
1) "1"
2) "2"
127.0.0.1:6379[14]> sdiff s1 s2 s3
1) "1"
2) "2"
127.0.0.1:6379[14]> sinter s1 s2
1) "3"
2) "4"
3) "5"
4) "6"
127.0.0.1:6379[14]> sinter s1 s2  s3
1) "5"
2) "6"
127.0.0.1:6379[14]> sunion s1 s2
1) "1"
2) "2"
3) "3"
4) "4"
5) "5"
6) "6"
7) "7"
127.0.0.1:6379[14]> sdiffstore s1diffs2 s1 s2
(integer) 2
127.0.0.1:6379[14]> smembers s1diffs2
1) "1"
2) "2"

{% endhighlight %}

## 有序集合类型

有序集合在集合类型的基础上为每个元素关联了一个分数

ZADD key score member [score member ...]

增加元素

重新add可以覆盖原来的分数，分数可以是float类型

{% highlight python %}
127.0.0.1:6379[14]> zadd ranking 88 tom 89 peter 100 edward
(integer) 3
127.0.0.1:6379[14]> zadd ranking 88.8 tom
(integer) 0
127.0.0.1:6379[14]> zscore ranking tom
"88.799999999999997"
{% endhighlight %}


ZSCORE key member

获得元素分数

{% highlight python %}
127.0.0.1:6379[14]> zscore ranking peter
"89"
{% endhighlight %}

ZRANGE key start stop [WITHSCORES]  # 从小到大顺序

ZREVRANGE key start stop [WITHSCORES]  # 逆序

获取排名在某个范围的元素

默认返回元素，可以增加 WITHSCORES 参数则连同分数一起返回

{% highlight python %}

127.0.0.1:6379[14]> zadd age 12 lily 20 tom 25 jerry 30 jack
(integer) 4
127.0.0.1:6379[14]> zrange age 0 3
1) "lily"
2) "tom"
3) "jerry"
4) "jack"
127.0.0.1:6379[14]> zrevrange age 0 3
1) "jack"
2) "jerry"
3) "tom"
4) "lily"
127.0.0.1:6379[14]> zrevrange age 0 3 withscores
1) "jack"
2) "30"
3) "jerry"
4) "25"
5) "tom"
6) "20"
7) "lily"
8) "12"

{% endhighlight %}


ZRANGEBYSCORE key min max [WITHSCORES] [LIMIT offset count]

获取指定分数范围的元素，包含min 和max

-inf和+inf分别表示负无穷和正无穷

如果希望分数范围不包含端点值， 可以在分数前加上“(”符号

ZREVRANGEBYSCORE key max min [WITHSCORES] [LIMIT offset count]

会得到与 ZRANGEBYSCORE 相反的排序，注意 max 和min的位置也是相反的

{% highlight python %}
127.0.0.1:6379[14]> zrangebyscore age 15 28
1) "tom"
2) "jerry"
127.0.0.1:6379[14]> zrangebyscore age 15 28 withscores
1) "tom"
2) "20"
3) "jerry"
4) "25"
127.0.0.1:6379[14]> zrangebyscore age 15 28 withscores limit 1
(error) ERR syntax error
127.0.0.1:6379[14]> zrangebyscore age 15 28 withscores limit  0 1
1) "tom"
2) "20"
# 获取年龄大于15的
127.0.0.1:6379[14]> zrangebyscore age 15 +inf
1) "tom"
2) "jerry"
3) "jack"
# 如果希望分数范围不包含端点值， 可以在分数前加上“(”符号
127.0.0.1:6379[14]> zrangebyscore age 12 28
1) "lily"
2) "tom"
3) "jerry"
127.0.0.1:6379[14]> zrangebyscore age (12 28
1) "tom"
2) "jerry"

# 相反的顺序
127.0.0.1:6379[14]> zrevrangebyscore age 28 15 withscores
1) "jerry"
2) "25"
3) "tom"
4) "20"
{% endhighlight %}



ZINCRBY key increment member

增加一个元素的分数，increment 也可以是float类型

如果指定的元素不存在， Redis在执行命令前会先建立它并将它的分数赋为0再执行操作

{% highlight python %}

127.0.0.1:6379[14]> zscore age tom
"20"
127.0.0.1:6379[14]> zincrby age 5 tom
"25"
127.0.0.1:6379[14]> zincrby age 5.5 tom
"30.5"
# 不存在
127.0.0.1:6379[14]> zincrby age 5 tom2
"5"
{% endhighlight %}

ZCARD key

获得有序集合元素数量

{% highlight python %}
127.0.0.1:6379[14]> zcard age
(integer) 5
{% endhighlight %}


ZCOUNT key min max

获得min到max直接元素的数量



{% highlight python %}
127.0.0.1:6379[14]> zrange age 0 5 withscores
 1) "tom2"
 2) "5"
 3) "lily"
 4) "12"
 5) "jerry"
 6) "25"
 7) "jack"
 8) "30"
 9) "tom"
10) "30.5"
127.0.0.1:6379[14]> zcount age 5 25
(integer) 3
{% endhighlight %}

ZREM key member [member ...]

删除元素

{% highlight python %}
127.0.0.1:6379[14]> zrem age tom2 tom
(integer) 2
127.0.0.1:6379[14]> zrange age 0 5 withscores
1) "lily"
2) "12"
3) "jerry"
4) "25"
5) "jack"
6) "30"
{% endhighlight %}


ZREMRANGEBYRANK key start stop

按照排名顺序删除元素

{% highlight python %}
127.0.0.1:6379[14]> zrange age 0 5 withscores
1) "lily"
2) "12"
3) "jerry"
4) "25"
5) "jack"
6) "30"
127.0.0.1:6379[14]> zremrangebyrank age 0 2
(integer) 3
127.0.0.1:6379[14]> zrange age 0 5 withscores
(empty list or set)
{% endhighlight %}


ZREMRANGEBYSCORE key min max

按照分数区间删除元素

{% highlight python %}
127.0.0.1:6379[14]> zadd age 10 tom 15 lily 20 kate 25 jerry
(integer) 4
127.0.0.1:6379[14]> zrange age 0 5
1) "tom"
2) "lily"
3) "kate"
4) "jerry"
127.0.0.1:6379[14]> zremrangebyscore age 10 15
(integer) 2

{% endhighlight %}


ZRANK key member  # 从小到大排名

ZREVRANK key member # 从大到小

获取元素排名（排名从0开始）

{% highlight python %}

127.0.0.1:6379[14]> zadd age 10 tom 15 lily 20 kate 25 jerry
(integer) 2
127.0.0.1:6379[14]> zrank age tom
(integer) 0
127.0.0.1:6379[14]> zrevrank age tom
(integer) 3
127.0.0.1:6379[14]> zrevrank age lily
(integer) 2

{% endhighlight %}


ZINTERSTORE destination numkeys key [key …] [WEIGHTS weight [weight …]] [AGREGATE SUM\MIN\MAX]

求交集；并集为 ZUNIONSTORE

结果存储在destination键中， 返回值为destination键中的元素个数

destination键中元素的分数是由 AGGREGATE参数决定的：

* SUM时（也就是默认值），参与计算的有序集合元素的和
* MINI时，参与计算的有序集合元素的最小值
* MAX时，参与计算的有序集合元素的最大值

ZINTERSTORE命令还能够通过WEIGHTS参数设置每个集合的权重，

每个集合在参与计算时元素的分数会被乘上该集合的权重

{% highlight python %}
# 默认sum
127.0.0.1:6379[14]> zadd z1 2 a 3 b 4 c
(integer) 3
127.0.0.1:6379[14]> zadd z2 5 a 6 b 7 c
(integer) 1
127.0.0.1:6379[14]> zinterstore z 2 z1 z2
(integer) 3
127.0.0.1:6379[14]> zrange z 0 10 withscores
1) "a"
2) "7"
3) "b"
4) "9"
5) "c"
6) "11"
# MAX
127.0.0.1:6379[14]> zadd z2 1 a
(integer) 0
127.0.0.1:6379[14]> zrange z2 0 5 withscores
1) "a"
2) "1"
3) "b"
4) "6"
5) "c"
6) "7"
7) "d"
8) "8"
127.0.0.1:6379[14]> zinterstore z 2 z1 z2 aggregate max
(integer) 3
127.0.0.1:6379[14]> zrange z 0 5  withscores
1) "a"
2) "2"
3) "b"
4) "6"
5) "c"
6) "7"
# MIN
127.0.0.1:6379[14]> zinterstore z 2 z1 z2 aggregate min
(integer) 3
127.0.0.1:6379[14]> zrange z 0 5 withscores
1) "a"
2) "1"
3) "b"
4) "3"
5) "c"
6) "4"
# WEIGHTS
127.0.0.1:6379[14]> zinterstore z 2 z1 z2 weights 1 2
(integer) 3
127.0.0.1:6379[14]> zrange z 0 5 withscores
1) "a"
2) "4"
3) "b"
4) "15"
5) "c"
6) "18"
{% endhighlight %}


# 三、特性

## 事务

Redis通过 MULTI、EXEC、WATCH 等命令实现事务功能。

事务一般经历三个阶段：

* 事务开始
* 命令入队
* 事务执行

MULTI 命令的执行意味着事务的开始

处于事务开启状态，后续的操作就会被放入队列（除了EXEC DISCARD WIATCH MULTI）

EXEC 执行事务


注意：

当检测到语法错误的时候，不执行任务队列的任何命令。

如果语法没有错误，实际命令错误，无法检查，则不执行该出错命令，其他命令执行

错误的避免，由程序员负责

{% highlight python %}
# 关注列表，与被关注列表
127.0.0.1:6379[14]> sadd user:1:following 2
QUEUED
127.0.0.1:6379[14]> sadd user:2:followers 2
QUEUED
127.0.0.1:6379[14]> exec
1) (integer) 1
2) (integer) 1

# 语法错误，不执行
127.0.0.1:6379[14]> multi
OK
127.0.0.1:6379[14]> set user mouren
QUEUED
127.0.0.1:6379[14]> set ue
(error) ERR wrong number of arguments for 'set' command
127.0.0.1:6379[14]> exec
(error) EXECABORT Transaction discarded because of previous errors.
127.0.0.1:6379[14]> get user
(nil)

# 命令错误，其他语句执行
127.0.0.1:6379[14]> multi
OK
127.0.0.1:6379[14]> set user mouren
QUEUED
127.0.0.1:6379[14]> sadd user xx
QUEUED
127.0.0.1:6379[14]> set user1 mouren1
QUEUED
127.0.0.1:6379[14]> exec
1) OK
2) (error) WRONGTYPE Operation against a key holding the wrong kind of value
3) OK
127.0.0.1:6379[14]> mget user user1
1) "mouren"
2) "mouren1"

{% endhighlight %}



WATCH 是个乐观锁，可以再EXEC命令执行前，监视任意数据库键

并在EXEC执行时，检查被监视的键是否改动过，如果改动过则拒绝执行事务

{% highlight python %}
127.0.0.1:6379[14]> set key 1
OK
127.0.0.1:6379[14]> watch key
OK
127.0.0.1:6379[14]> set key 2
OK
127.0.0.1:6379[14]> multi
OK
127.0.0.1:6379[14]> set key 3
QUEUED
127.0.0.1:6379[14]> exec
(nil)
127.0.0.1:6379[14]> get key
"2"
{% endhighlight %}


DISCARD 提前结束事务

{% highlight python %}
127.0.0.1:6379[14]> set key 1
OK
127.0.0.1:6379[14]> multi
OK
127.0.0.1:6379[14]> set key 2
QUEUED
127.0.0.1:6379[14]> discard
OK
127.0.0.1:6379[14]> exec
(error) ERR EXEC without MULTI
127.0.0.1:6379[14]> get key
"1"
{% endhighlight %}

UNWATCH 取消所有监控

执行EXEC命令后会取消对所有键的监控，

如果不想执行事务中的命令也可以使用UNWATCH命令来取消监控

比如实现类似HSETNX命令

{% highlight python %}

def hsetxx(key, field, value):
    WATCH key
    isFieldExists = HEXISTS key field
    if isFieldExists:
        MULTI
        HSET key field value
        EXEC
    else:
        UNWATCH
    return isFieldExists


{% endhighlight %}









# 四、实际应用

## 访问频率控制

要求：每分钟每个用户最多访问100个页面

思路：

每个用户使用 rate:limiting:IP 作为键，

每次访问则使用INCR命令递增，同时设置键生命周期为1分钟

{% highlight python %}

isKeyExists = EXISTS rate:limiting:IP
if isKeyExists:
    times = INCR rate:limiting:IP
if times > 100:
    print "deny!"
    exit
else:
    INCR rate:limiting:IP
    EXPIRE rate:limiting:IP 60

{% endhighlight %}

有个问题 如果执行到倒数第二行，突然退出，则删除该键前最多访问10次

使用事务来修正
{% highlight python %}

isKeyExists = EXISTS rate:limiting:IP
if isKeyExists:
    times = INCR rate:limiting:IP
if times > 10:
    print "deny!"
    exit
else:
    MULTI
    INCR rate:limiting:IP
    EXPIRE rate:limiting:IP 60
    EXEC

{% endhighlight %}


还有问题：

如果用户在一分钟的第一秒访问1次，最后一秒访问9次；

在下分钟的第一秒内访问10次，则两秒内访问了19次，突破了每分钟10次限制

解决：

使用列表记录用户最近的访问时间

一旦键中的元素超过10个， 就判断时间最早的元素距现在的时间是否小于1分钟。

如果是则表示用户最近1分钟的访问次数超过了10次；

如果不是就将现在的时间加入到列表中， 同时把最早的元素删除。

{% highlight python %}

listLength = LLEN rate:limiting:IP

if listLength < 10:
    LPUSH rate:limiting:IP now()
else:
    time = LINDEX rate:limiting:IP -1

if now() - time < 60:
    print "deny!"
    exit
else:
    LPUSH rate:limiting:IP now()
    LTRIM rate:limiting:IP 0 9


{% endhighlight %}



## 大量用户统计活跃用户

1亿个用户，每个用户登录则记为活跃，否则不活跃

统计每周、每月、连续多少天活跃用户来做活动

思路：使用位图法记录用户是否活跃

* 用户登录，每天按照日期生成一个位图，登录用户的ID位上的bit值设置为1
* 把一周的位图 and 计算

{% highlight python %}

127.0.0.1:6379[14]> setbit mon 100000000 0
(integer) 0
127.0.0.1:6379[14]> setbit mon 3 1
(integer) 0
127.0.0.1:6379[14]> setbit mon 5 1
(integer) 0
127.0.0.1:6379[14]> setbit mon 7 1
(integer) 0
127.0.0.1:6379[14]> setbit tue 100000000 0
(integer) 0
127.0.0.1:6379[14]> setbit tue 3 1
(integer) 0
127.0.0.1:6379[14]> setbit tue 5 1
(integer) 0
127.0.0.1:6379[14]> setbit tue 8 1
(integer) 0
127.0.0.1:6379[14]> setbit wen 100000000 0
(integer) 0
127.0.0.1:6379[14]> setbit wen 3 1
(integer) 0
127.0.0.1:6379[14]> setbit wen 4 1
(integer) 0
127.0.0.1:6379[14]> setbit wen 6 1
(integer) 0
127.0.0.1:6379[14]> bitop and res mon tue wen
(integer) 12500001
127.0.0.1:6379[14]> bitcount res
(integer) 1

{% endhighlight %}

优点：

* 节约空间，1亿个用户，1亿个bit，大约10M字符
* 方便计算


## 安全队列

* rpoplpush task bak
* 接收返回值，并做业务处理
* 如果成功 rpop bak 清除任务
* 如果不成功，下次从bak取任务


## 限制列表中元素个数

只保留100条日志

LPUSH logs newlog

LTRIM logs 0 99

## python调用redis存放pickle数据

{% highlight python %}

def dumps_zip(value):
    pickled_value = pickle.dumps(value, 2)
    zip_pickled_value = zlib.compress(pickled_value)
    return zip_pickled_value


def loads_zip(zip_pickled_value):
    pickled_value = zlib.decompress(zip_pickled_value)
    value = pickle.loads(pickled_value)
    return value


if settings.REDIS_DATA_ZIP:
    r_loads = loads_zip
    r_dumps = dumps_zip
else:
    r_loads = pickle.loads
    r_dumps = lambda v: pickle.dumps(v, 2)


class PickledRedis(StrictRedis):
    """
    a pickled redis client
    """
    def get(self, name):
        pickled_value = super(PickledRedis, self).get(name)
        if pickled_value is None:
            return None
        return r_loads(pickled_value)

    def set(self, name, value, ex=None, px=None, nx=False, xx=False):
        return super(PickledRedis, self).set(name, r_dumps(value), ex, px, nx, xx)
{% endhighlight %}


## 分布式锁的实现

利用SETNX 很容易实现分布式锁

SETNTX lock_key now+expires+1

* 返回1，则客户端获得锁，并设置时间，最后可以 del lock_key 释放锁
* 返回0，则被其他用户占用

问题：持有锁的客户端失败或者崩溃不能释放锁，怎么办？

不能通过简单的del来删除锁，然后setnx一次，多个客户端检测锁超时的时候，会出现竞态

1. C0 操作超时，但持有锁。
2. C1 C2 检测lock_key时间戳，发现过期
3. C1 发送del lock_key
4. C1 发送 SETNX lock_key 成功了
5. C2 发送del lock_key
6. C2 发送 SETNX lock_key 成功了
7. 结果C1 C2都拿到了锁

解决方案：

1. C3 发现lock_key过期
2. GETSET lock_key now+expires+1
3. C3 拿到的时间戳仍然是过期的，说明C3 可以获得锁
4. C4 同时操作，GETSET 由于C3重新设置了时间，C4获得的时间是没有过期的，不能获得锁


{% highlight python %}
class RedisLock(object):
    def __init__(self, r, key, expires=3, timeout=3):
        """
        Distributed locking using Redis SETNX and GETSET.

        Usage::

            with RedisLock('my_lock'):
                print "Critical section"

        :param  expires     We consider any existing lock older than
                            ``expires`` seconds to be invalid in order to
                            detect crashed clients. This value must be higher
                            than it takes the critical section to execute.
        :param  timeout     If another client has already obtained the lock,
                            sleep for a maximum of ``timeout`` seconds before
                            giving up. A value of 0 means we never wait.
        """
        self.redis = r
        self.key = key
        self.timeout = timeout
        self.expires = expires

    def __enter__(self):
        timeout = self.timeout
        while timeout >= 0:
            expires = time.time() + self.expires + 1

            if self.redis.setnx(self.key, expires):
                # We gained the lock; enter critical section
                return

            current_value = self.redis.get(self.key)

            # We found an expired lock and nobody raced us to replacing it
            if current_value and float(current_value) < time.time() and \
                self.redis.getset(self.key, expires) == current_value:
                    return

            timeout -= 1
            time.sleep(1)

        raise LockTimeout("Timeout whilst waiting for lock")

    def __exit__(self, exc_type, exc_value, traceback):
        self.redis.delete(self.key)


class LockTimeout(BaseException):
    pass
{% endhighlight %}
