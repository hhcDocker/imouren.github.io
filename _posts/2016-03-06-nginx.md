---
layout: post
title:  "nginx笔记"
date:   2016-03-06 11:05:31
categories: nginx
tags: nginx
---

* content
{:toc}

## nginx 的安装

系统要求：

内核为linux 2.6及以上版本的操作系统，因为linux2.6及以上版本内核才支持epoll

可以使用`uname -a`查看内核信息


{% highlight python %}
# 下载最新源码
wget http://nginx.org/download/nginx-1.9.12.tar.gz
# 解压
tar zxvf nginx-1.9.12.tar.gz
cd nginx-1.9.12
# 安装依赖
yum install pcre pcre-devel zlib-devel zlib openssl openssl-devel -y
# 源码安装
./configure --prefix=/usr/local/nginx
make && make install
{% endhighlight %}

启动nginx
{% highlight python %}
cd /usr/local/nginx/sbin
./nginx  # 会读取默认路径下的配置文件 /usr/local/nginx/conf/nginx.conf
./nginx -c /tmp/nginx.conf # 指定特定的配置文件
{% endhighlight %}

查看
{% highlight python %}
netstat -antp|grep nginx
# 结果
tcp        0      0 0.0.0.0:80                  0.0.0.0:*                   LISTEN      30798/nginx
{% endhighlight %}

## nginx 的信号控制

* TERM, INT       快速关闭进程
* QUIT    优雅的关闭进程,即等请求结束后再关闭
* HUP     改变配置文件,平滑的重读配置文件
* USR1    重读日志,在日志按月/日分割时有用
* USR2    Upgrade Executable on the fly 平滑的升级
* WINCH   优雅关闭旧的进程(配合USR2来进行升级)

语法：

Kill -信号选项 nginx的主进程号


## nginx 段配置

简单的配置
{% highlight python %}
worker_processes  1;

error_log  logs/error.log  notice;

pid        logs/nginx.pid;


events {
    worker_connections  1024;
}


http {
    include       mime.types;
    default_type  application/octet-stream;

    log_format  main  '$remote_addr - $remote_user [$time_local] "$request" '
                      '$status $body_bytes_sent "$http_referer" '
                      '"$http_user_agent" "$http_x_forwarded_for"';

    access_log  logs/access.log  main;

    sendfile        on;
    #tcp_nopush     on;

    keepalive_timeout  0;

    gzip  on;

    server {
        listen       80;
        server_name  localhost;

        location / {
            root   html;
            index  index.html index.htm;
        }
}
{% endhighlight %}


配置虚拟主机
{% highlight python %}
# 基于域名的虚拟主机
server {
listen       80;
server_name  a.com;

location / {
    root   html;
    index  index.html index.htm;
}

# 基于端口的虚拟主机
server {
listen       8080;
server_name  192.168.1.100;

location / {
    root   html;
    index  index.html index.htm;
}
{% endhighlight %}

## 配置项的单位

当指定空间大小的时候，可以使用单位：

* k 千字节KB
* M 兆字节MB

gzip_buffers 4 8k;

client_max_body_size 64M;

当指定时间时，可以使用单位：

* ms 毫秒
* s 秒
* m 分钟
* h 小时
* d 天
* w 周 7天
* M 月30天
* y 年 365天

expires 10y;

client_body_timeout 2m;

## nginx 日志

日志格式，默认 main

{% highlight python %}
log_format  main  '$remote_addr - $remote_user [$time_local] "$request" '
                      '$status $body_bytes_sent "$http_referer" '
                      '"$http_user_agent" "$http_x_forwarded_for"';
{% endhighlight %}

http_x_forwarded_for 在经过代理时,代理把你的本来IP加在此头信息中,传输你的原始IP

声明一个独特的log_format，并命名
{% highlight python %}
log_format  mylog '$remote_addr- "$request" '
                     '$status $body_bytes_sent "$http_referer" '
                        '"$http_user_agent" "$http_x_forwarded_for"';
{% endhighlight %}


Nginx允许针对不同的server做不同的Log

access_log   logs/access_xx.log     mylog;

声明log      log位置                log格式;





ngx_http_core_module 模块提供的变量

![nginx_1](/files/nginx_1.png)

![nginx_2](/files/nginx_2.png)

访问上游服务器用到的变量

![nginx_3](/files/nginx_3.png)

按天分割日志：

脚本
{% highlight python %}
#!/bin/bash
base_path='/usr/local/nginx/logs'
log_path=$(date -d yesterday +"%Y%m")
day=$(date -d yesterday +"%d")
mkdir -p $base_path/$log_path
mv $base_path/access.log $base_path/$log_path/access_$day.log
#echo $base_path/$log_path/access_$day.log
kill -USR1 `cat /usr/local/nginx/logs/nginx.pid`
{% endhighlight %}

定时任务
{% highlight python %}
01 00 * * * /xxx/path/split.sh  每天0时1分
{% endhighlight %}


## 文件路径定义

### 以root方式设置资源路径
{% highlight python %}
location /download/ {
        root /opt/web/htm/;
}
{% endhighlight %}

请求URI是/download/index/test.html，web服务器将返回服务器上/opt/web/html/download/index/test.html 内容

### 以alias 方式设置资源路径
{% highlight python %}
location /conf {
        alias /usr/local/nginx/conf/;
}
{% endhighlight %}

相当于用root设置
{% highlight python %}
location /conf {
        root /usr/local/nginx/;
}
{% endhighlight %}

alias后面还可以添加正则表达式
{% highlight python %}
location ~ ^/test/(\w+)\.(\w+)$ {
        alias /usr/local/nginx/$2/$1.$2;
}
{% endhighlight %}

### 访问首页

{% highlight python %}
location / {
        root path;
        index index.html index.htm;
}
{% endhighlight %}

访问UIR / ，nginx会按照顺序访问 path/index.html path/index.htm 的内容

### 根据HTTP返回码重定向页面
{% highlight python %}
语法 error_page code [code ...] [=|=answer-code] uri|@named_location

error_page 404   /404.html;
error_page 502 503 504   /50x.html;
error_page 403   http://example.com/forbidden.html;
error_page 404   = @fetch;
{% endhighlight %}

虽然重定向了URI，但是返回HTTP错误码还是原来的，可以通过=来修改错误码

{% highlight python %}
error_page 404  =200 /empty.gif;
error_page 403  =403 /forbidden.gif;
{% endhighlight %}

是否允许递归使用error_page
{% highlight python %}
recursive_error_pages [on|off];  # 默认off
{% endhighlight %}

## location 用法

{% highlight python %}
location [=|~|~*|^~] uri {}

= 把URI作为字符串，和参数的uri做完全匹配

~ 正则匹配，大小写敏感

~* 忽略大小写

^~ 只匹配前半部分
{% endhighlight %}

匹配的优先级：

* =前缀的指令严格匹配这个查询。如果找到，停止搜索。
* 所有剩下的常规字符串，最长的匹配。如果这个匹配使用^前缀，搜索停止。
* 正则表达式匹配，在配置文件中定义的顺序。
* 如果第3条规则产生匹配的话，结果被使用。否则，如同从第2条规则被使用

看如下配置，是如何处理的？

{% highlight python %}
location = / {
        root   /var/www/html/;
        index  index.htm index.html;
}

location / {
        root   /usr/local/nginx/html;
        index  index.html index.htm;
}
{% endhighlight %}

* 优先匹配精准匹配，"/" 得到index页为 "index.htm"
* 再次访问"/index.htm" 此处uri已经是 "/index.htm"
* 匹配 没有等号的"/"，根目录为"/usr/local/nginx/html"
* 最终访问结果 /usr/local/nginx/html/index.htm


正则优先于普通字符

{% highlight python %}
location / {
    root   /usr/local/nginx/html;
    index  index.html index.htm;
}

location ~ image {
   root /var/www/;
   index index.html;
}

{% endhighlight %}

访问 xx.com/image/logo.jpg，两条location 都符合

这个会匹配正则的规则，访问到 /var/www/image/logo.jpg


最长匹配，优先匹配到

{% highlight python %}
location / {
     root   /usr/local/nginx/html;
     index  index.html index.htm;
 }

location /foo.html {
    root /var/www/html;
     index index.html;
}

{% endhighlight %}

访问 xx.com/foo.html，两条location 都符合

这个会匹配到最长的匹配 /foo.html ，访问到 /var/www/html/foo.html


## rewrite 重写 完成伪静态


